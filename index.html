<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Javascript by kamesh-a</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Javascript</h1>
      <h2 class="project-tagline">Javscript Introduction and workshop</h2>
      <a href="https://github.com/kamesh-a/Javascript" class="btn">View on GitHub</a>
      <a href="https://github.com/kamesh-a/Javascript/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/kamesh-a/Javascript/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>What is Javascript ? </p>

<blockquote>
<p>client side scripting
wiki : An object-oriented computer programming language commonly used to create interactive effects within web browsers</p>
</blockquote>

<ul>
<li>Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM).</li>
<li>Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. 

<ol>
<li>Communicate with a database</li>
<li>Provide continuity of information from one invocation to another of the application</li>
<li>Perform file manipulations on a server</li>
</ol>
</li>
</ul>

<p>Everything in javascript is an object. Aww!!!</p>

<blockquote>
<p>Act like objects. ( Explained in Literals section )</p>
</blockquote>

<p><code>Arrays, functions</code>, even <code>numbers</code>! Because of this, you can do some really interesting things, such as modifying the prototypes of Objects, Arrays, etc.</p>

<ul>
<li>Written in <code>c++</code> ( v8 chrome <code>c++</code>, Spidermonkey firefox <code>c++</code> and Rhino <code>java</code> )</li>
<li><p>primitive type ( <code>Boolean , Number , null , undefined and String</code> ( ex : <code>var letter = 'abc';</code> ) )</p></li>
<li>
<p>non-primitive ( Object, Regex and Array )</p>

<blockquote>
<p>Compared by unique identity.</p>
</blockquote>
</li>
</ul>

<h3>
<a id="topics-which-are-covered" class="anchor" href="#topics-which-are-covered" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Topics which are covered</h3>

<ul>
<li>Primitive <code>vs</code> non-primitive</li>
<li>Falsy <code>vs</code> Truthy</li>
<li>Function and Hoisting</li>
<li>Scope</li>
<li>IIFE</li>
<li>Objects</li>
<li>Literals <code>vs</code> Wrappers and Immutable <code>vs</code> non-Immutable ( primitives section, find in primitives chapter in ebook )</li>
<li>Inheritance</li>
<li>this</li>
<li>Closure</li>
<li>Synchronous <code>vs</code> Asynchronous</li>
<li>Event Loop</li>
</ul>

<h3>
<a id="topics-which-are-not-covered" class="anchor" href="#topics-which-are-not-covered" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Topics which are not covered</h3>

<ul>
<li>Object.defineProperties or propertyDescriptor and accessors.</li>
<li>unicode</li>
<li>Date</li>
<li>Math</li>
<li>Regular expressions</li>
<li>module loaders</li>
</ul>

<h3>
<a id="1-primitive-vs-non-primitive" class="anchor" href="#1-primitive-vs-non-primitive" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. Primitive <code>vs</code> non-primitive</h3>

<p>Primitive : Compared by value.</p>

<ul>
<li>Booleans: true, false</li>
<li>Numbers: 1736, 1.351</li>
<li>Strings: 'abc', "abc"</li>
<li>Two “nonvalues”: undefined, null</li>
</ul>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-c1">3</span> <span class="pl-k">===</span> <span class="pl-c1">3</span>
<span class="pl-c1">true</span>
<span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>
<span class="pl-c1">true</span></pre></div>

<p>non-primitive :
All nonprimitive values are objects. The most common kinds of objects are:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">Objects</span> (Literals)<span class="pl-k">:</span>
{
    firstName<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,
    lastName<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Doe<span class="pl-pds">'</span></span>
}

<span class="pl-en">Arrays</span> (Literals)<span class="pl-k">:</span> 
[<span class="pl-s"><span class="pl-pds">'</span>item1<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>item2<span class="pl-pds">'</span></span>];
</pre></div>

<p>compared by reference.
Identities are compared; every value has its own identity:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> ({} <span class="pl-k">===</span> {})  <span class="pl-c">// two different empty objects</span>
<span class="pl-c1">false</span>

<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {};
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj2 <span class="pl-k">=</span> obj1;
<span class="pl-k">&gt;</span> obj1 <span class="pl-k">===</span> obj2
<span class="pl-c1">true</span></pre></div>

<h3>
<a id="non-values" class="anchor" href="#non-values" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>non-values</h3>

<p>To represent missing information in language.</p>

<pre><code>undefined:
no value, non existence or Uninitialized or missing values are 
reprsented as undefined

null:
null means “no object.” It is used as a nonvalue whenever an object is expected (parameters, last in a chain of objects, etc.).( no properties for both not event toString())
</code></pre>

<h4>
<a id="2-falsy-vs-truthy-" class="anchor" href="#2-falsy-vs-truthy-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. Falsy <code>vs</code> Truthy :</h4>

<p>Whenever JavaScript expects a boolean value (e.g., for the condition of an if statement)
Falsy values in language, equality or comparision check not needed</p>

<ul>
<li>undefined, null</li>
<li>Boolean: false</li>
<li>Number: 0, NaN</li>
<li>String: ''</li>
</ul>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> falsyArr <span class="pl-k">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">undefined</span>, <span class="pl-c1">null</span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">NaN</span>];

<span class="pl-smi">falsyArr</span>.<span class="pl-en">forEach</span>(<span class="pl-k">function</span>(<span class="pl-smi">element</span>, <span class="pl-smi">index</span>) {
    <span class="pl-k">if</span> (element)
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>Truthy value : <span class="pl-pds">'</span></span>, element);
    <span class="pl-k">else</span>
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>Falsy value : <span class="pl-pds">'</span></span>, element);
});</pre></div>

<ul>
<li>Truthy values ( Note : Object and empty array are considered to be true )</li>
</ul>

<pre><code>var truthyArr = [1, -1, true, 'string', [],{},function(){},RegExp];

truthyArr.forEach(function(element, index) {
    if (element)
        console.log('Truthy value : ', element);
    else
        console.log('Falsy value : ', element);
});
</code></pre>

<h3>
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functions</h3>

<p>Functions are values that can be called. One way of defining a function is called a function declaration. For example, the following code defines the function id that has a single parameter, x:</p>

<p>```function id(x) {
    return x;
}</p>

<pre><code>The return statement returns a value from id. You can call a function by mentioning its name, followed by arguments in parentheses:
```javascript
&gt; id('hello')
'hello'
</code></pre>

<p>If you don’t return anything from a function, undefined is returned (implicitly):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">f</span>() { }
<span class="pl-k">&gt;</span> <span class="pl-en">f</span>()
<span class="pl-c1">undefined</span>
</pre></div>

<p>The Three Roles of Functions in JavaScript
Once you have defined a function as just shown, it can play several roles:
Nonmethod function (“normal function”)
You can call a function directly. Then it works as a normal function. Here’s an example invocation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">id</span>(<span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>)</pre></div>

<p>Constructor
You can invoke a function via the new operator. Then it becomes a constructor, a factory for objects. Here’s an example invocation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Date</span>() <span class="pl-c">// returns an object.</span></pre></div>

<p>Method
You can store a function in a property of an object, which turns it into a method that you can invoke via that object. Here’s an example invocation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">obj</span>.<span class="pl-c1">method</span>()</pre></div>

<p>“Parameter” <code>Versus</code> “Argument”
The terms parameter and argument are often used interchangeably, Parameters are used to define a function. They are also called formal parameters and formal arguments. In the following example, param1 and param2 are parameters:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">param1</span>, <span class="pl-smi">param2</span>) {
    <span class="pl-k">...</span>
}</pre></div>

<p>Arguments are used to invoke a function. They are also called actual parameters and actual arguments. In the following example, 3 and 7 are arguments:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">foo</span>(<span class="pl-c1">3</span>, <span class="pl-c1">7</span>);</pre></div>

<p>Defining Functions
This section describes three ways to create a function:</p>

<div class="highlight highlight-source-js"><pre>Via a <span class="pl-k">function</span> expression
Via a <span class="pl-k">function</span> declaration
Via the constructor <span class="pl-en">Function</span>()</pre></div>

<p>All functions are objects, instances of <code>Function</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">id</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x;
}
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(id <span class="pl-k">instanceof</span> <span class="pl-c1">Function</span>); <span class="pl-c">// true</span></pre></div>

<p>Therefore, functions get their methods from Function.prototype.</p>

<p>Function Expressions
A function expression produces a <code>value—a</code> function object. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">add</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">x</span>, <span class="pl-smi">y</span>) { <span class="pl-k">return</span> x <span class="pl-k">+</span> y };
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">add</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)); <span class="pl-c">// 5</span></pre></div>

<p>The preceding code assigned the result of a function expression to the variable add and called it via that variable. The value produced by a function expression can be assigned to a variable (as shown in the last example), passed as an argument to another function, and more. Because normal function expressions don’t have a name, they are also called <code>anonymous function expressions</code>.</p>

<p>Named function expressions</p>

<p>You can give a function expression a name. Named function expressions allow a function expression to refer to itself, which is useful for self-recursion:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">fac</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">me</span>(<span class="pl-smi">n</span>) {
    <span class="pl-k">if</span> (n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> n <span class="pl-k">*</span> <span class="pl-en">me</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span>);
    } <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    }
};
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">fac</span>(<span class="pl-c1">3</span>)); <span class="pl-c">// 6</span>

<span class="pl-k">var</span> <span class="pl-en">fac</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">n</span>) {
    <span class="pl-k">if</span> (n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> n <span class="pl-k">*</span> <span class="pl-en">fac</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span>);
    } <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    }
};
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">fac</span>(<span class="pl-c1">3</span>)); <span class="pl-c">// 6</span>
</pre></div>

<p>NOTE
The name of a named function expression is only accessible inside the function expression:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">repeat</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">me</span>(<span class="pl-smi">n</span>, <span class="pl-smi">str</span>) {
    <span class="pl-k">return</span> n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> str <span class="pl-k">+</span> <span class="pl-en">me</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span>, str) <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>;
};
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">repeat</span>(<span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">'</span>Yeah<span class="pl-pds">'</span></span>)); <span class="pl-c">// YeahYeahYeah</span>
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(me); <span class="pl-c">// ReferenceError: me is not defined</span></pre></div>

<p>Function Declarations
The following is a function declaration:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}
</pre></div>

<p>A function declaration declares a new variable, creates a function object, and assigns it to the variable.</p>

<p>The Function Constructor
The constructor Function() evaluates JavaScript code stored in strings. For example, the following code is equivalent to the previous example:</p>

<pre><code>var add = new Function('x', 'y', 'return x + y');
</code></pre>

<h4>
<a id="hoisting" class="anchor" href="#hoisting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hoisting</h4>

<p>Hoisting means “moving to the beginning of a scope.” Function declarations are hoisted completely, variable declarations only partially.
Function declarations are completely hoisted. That allows you to call a function before it has been declared:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">foo</span>();
<span class="pl-k">function</span> <span class="pl-en">foo</span>() {  <span class="pl-c">// this function is hoisted</span>
    <span class="pl-k">...</span>
}</pre></div>

<p>The reason the preceding code works is that JavaScript engines move the declaration of foo to the beginning of the scope. They execute the code as if it looked like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">...</span>
}
<span class="pl-en">foo</span>();

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">bar</span>();  <span class="pl-c">// OK, bar is hoisted</span>
    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-k">...</span>
    }
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">bar</span>();  <span class="pl-c">// Not OK, bar is still undefined</span>
    <span class="pl-k">var</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
        <span class="pl-c">// ...</span>
    };
}
</pre></div>

<p>var declarations are hoisted, too, but only the declarations, not assignments made with them. Therefore, using a var declaration and a function expression similarly to the previous example results in an error:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">foo</span>();  <span class="pl-c">// TypeError: undefined is not a function</span>
<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
    <span class="pl-k">...</span>
};</pre></div>

<p>Only the variable declaration is hoisted. The engine executes the preceding code as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo;
<span class="pl-en">foo</span>();  <span class="pl-c">// TypeError: undefined is not a function</span>
<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
    <span class="pl-k">...</span>
};</pre></div>

<p>The Name of a Function
Most JavaScript engines support the nonstandard property name for function objects. Function declarations have it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">function</span> <span class="pl-en">f1</span>() {}
<span class="pl-k">&gt;</span> <span class="pl-smi">f1</span>.<span class="pl-c1">name</span>
<span class="pl-s"><span class="pl-pds">'</span>f1<span class="pl-pds">'</span></span></pre></div>

<p>The name of anonymous function expressions is the empty string:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">var</span> <span class="pl-en">f2</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {};
<span class="pl-k">&gt;</span> <span class="pl-smi">f2</span>.<span class="pl-c1">name</span>
<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span></pre></div>

<p>Named function expressions, however, do have a name:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">var</span> <span class="pl-en">f3</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">myName</span>() {};
<span class="pl-k">&gt;</span> <span class="pl-smi">f3</span>.<span class="pl-c1">name</span>
<span class="pl-s"><span class="pl-pds">'</span>myName<span class="pl-pds">'</span></span></pre></div>

<p>The name of a function is useful for debugging. Some people always give their function expressions names for that reason.
Which Is Better: A Function Declaration or a Function Expression?
Should you prefer a function declaration like the following?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">id</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x;
}</pre></div>

<p>Or the equivalent combination of a var declaration plus a function expression?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">id</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x;
};</pre></div>

<p>They are basically the same, but function declarations have two advantages over function expressions:
They are hoisted (see Hoisting), so you can call them before they appear in the source code.
They have a name (see The Name of a Function). However, JavaScript engines are getting better at inferring the names of anonymous function expressions.</p>

<p>More Control over Function Calls: call(), apply(), and bind()
call(), apply(), and bind() are methods that all functions have (remember that functions are objects and therefore have methods). They can supply a value for <code>this</code> when invoking a method and thus are mainly interesting in an object-oriented context (see Calling Functions While Setting this: call(), apply(), and bind()). <code>This</code> section explains two use cases for nonmethods.
<code>func.apply(thisValue, argArray)</code>
This method uses the elements of argArray as arguments while calling the function func; that is, the following two expressions are equivalent:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">func</span>(arg1, arg2, arg3)
<span class="pl-smi">func</span>.<span class="pl-c1">apply</span>(<span class="pl-c1">null</span>, [arg1, arg2, arg3])</pre></div>

<p>thisValue is the value that this has while executing func. It is not needed in a non-object-oriented setting and is thus null here.
apply() is useful whenever a function accepts multiple arguments in an array-like manner, but not an array.
Thanks to apply(), we can use Math.max() (see Other Functions) to determine the maximum element of an array:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-c1">Math</span>.<span class="pl-c1">max</span>(<span class="pl-c1">17</span>, <span class="pl-c1">33</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">33</span>
<span class="pl-k">&gt;</span> <span class="pl-c1">Math</span>.<span class="pl-smi">max</span>.<span class="pl-c1">apply</span>(<span class="pl-c1">null</span>, [<span class="pl-c1">17</span>, <span class="pl-c1">33</span>, <span class="pl-c1">2</span>])
<span class="pl-c1">33</span></pre></div>

<p>func.bind(thisValue, arg1, ..., argN)
This performs partial function application—a new function is created that calls func with this set to thisValue and the following arguments: first arg1 until argN, and then the actual arguments of the new function. thisValue is not needed in the following non-object-oriented setting, which is why it is null.
Here, we use bind() to create a new function plus1() that is like add(), but only requires the parameter y, because x is always 1:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}
<span class="pl-k">var</span> plus1 <span class="pl-k">=</span> <span class="pl-smi">add</span>.<span class="pl-en">bind</span>(<span class="pl-c1">null</span>, <span class="pl-c1">1</span>);
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">plus1</span>(<span class="pl-c1">5</span>));  <span class="pl-c">// 6</span></pre></div>

<p>In other words, we have created a new function that is equivalent to the following code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">plus1</span>(<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> <span class="pl-en">add</span>(<span class="pl-c1">1</span>, y);
}</pre></div>

<h3>
<a id="scope" class="anchor" href="#scope" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scope</h3>

<p>Declaring a Variable
In JavaScript, you declare a variable via a var statement before you use it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo;
foo <span class="pl-k">=</span> <span class="pl-c1">3</span>; <span class="pl-c">// OK, has been declared</span>
bar <span class="pl-k">=</span> <span class="pl-c1">5</span>; <span class="pl-c">// not OK, an undeclared variable</span></pre></div>

<p>You can also combine a declaration with an assignment, to immediately initialize a variable:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">3</span>;</pre></div>

<p>The value of an uninitialized variable is undefined:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">var</span> x;
<span class="pl-k">&gt;</span> x

<span class="pl-c1">undefined</span></pre></div>

<p>The scope of a variable
The scope of a variable are the locations where it is <code>accessible</code>. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> x;
}
<span class="pl-s"><span class="pl-pds">`</span><span class="pl-pds">`</span><span class="pl-pds">`</span>javascript</span>
<span class="pl-s">Here, the direct scope of x is the function foo().</span>
<span class="pl-s"></span>
<span class="pl-s">Nested :</span>
<span class="pl-s"></span>
<span class="pl-s"><span class="pl-pds">`</span><span class="pl-pds">`</span><span class="pl-pds">`</span></span>javascript
<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">arg</span>) {
    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>arg: <span class="pl-pds">'</span></span><span class="pl-k">+</span>arg);
    }
    <span class="pl-en">bar</span>();
}
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-en">foo</span>(<span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>)); <span class="pl-c">// arg: hello</span>
</pre></div>

<p>Shadowing :</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>global<span class="pl-pds">"</span></span>;
<span class="pl-k">function</span> <span class="pl-en">f</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>local<span class="pl-pds">"</span></span>;
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(x); <span class="pl-c">// local</span>
}
<span class="pl-en">f</span>();
<span class="pl-en">console</span>.<span class="pl-c1">log</span>(x); <span class="pl-c">// global</span></pre></div>

<p>Variables Are Function-Scoped
Most mainstream languages are <code>block-scoped</code>: variables “live inside” the innermost surrounding code block. Here is an example from Java:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> main(<span class="pl-k">String</span>[] args) {
    { <span class="pl-c">// block starts</span>
        <span class="pl-k">int</span> foo <span class="pl-k">=</span> <span class="pl-c1">4</span>;
    } <span class="pl-c">// block ends</span>
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(foo); <span class="pl-c">// Error: cannot find symbol</span>
}</pre></div>

<p>In contrast, JavaScript’s variables are <code>function-scoped</code>: only functions introduce new scopes; blocks are ignored when it comes to scoping. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">main</span>() {
    { <span class="pl-c">// block starts</span>
        <span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">4</span>;
    } <span class="pl-c">// block ends</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(foo); <span class="pl-c">// 4</span>
}
( Note <span class="pl-k">:</span> <span class="pl-c1">ES6</span> changed them <span class="pl-s"><span class="pl-pds">`</span>let<span class="pl-pds">`</span></span> <span class="pl-k">&amp;</span> <span class="pl-s"><span class="pl-pds">'</span>const<span class="pl-pds">'</span></span>)</pre></div>

<p>Variable Hoisting:</p>

<div class="highlight highlight-source-js"><pre>
<span class="pl-k">function</span> <span class="pl-en">f</span>() {
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(bar);  <span class="pl-c">// undefined</span>
    <span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>;
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(bar);  <span class="pl-c">// abc</span>
}

<span class="pl-k">function</span> <span class="pl-en">f</span>() {
    <span class="pl-k">var</span> bar;
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(bar);  <span class="pl-c">// undefined</span>
    bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>;
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(bar);  <span class="pl-c">// abc</span>
}


<span class="pl-k">&gt;</span> <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">123</span>;
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> x;
<span class="pl-k">&gt;</span> x
<span class="pl-c1">123</span>
</pre></div>

<h3>
<a id="iife-immediately-invoked-function-expression-iife-pronounced-iffy" class="anchor" href="#iife-immediately-invoked-function-expression-iife-pronounced-iffy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IIFE Immediately invoked function expression (IIFE, pronounced “iffy”)</h3>

<ul>
<li>It is immediately invoked</li>
<li>It must be an expression</li>
<li>The trailing semicolon is required</li>
</ul>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f</span>() {
    <span class="pl-k">if</span> (condition) {
        <span class="pl-k">var</span> tmp <span class="pl-k">=</span> <span class="pl-k">...</span>;
        <span class="pl-k">...</span>
    }
    <span class="pl-c">// tmp still exists here</span>
    <span class="pl-c">// =&gt; not what we want</span>
}

<span class="pl-k">function</span> <span class="pl-en">f</span>() {
    <span class="pl-k">if</span> (condition) {
        (<span class="pl-k">function</span> () {  <span class="pl-c">// open block</span>
            <span class="pl-k">var</span> tmp <span class="pl-k">=</span> <span class="pl-k">...</span>;
            <span class="pl-k">...</span>
        }());  <span class="pl-c">// close block</span>
    }
}

(<span class="pl-k">function</span> () { <span class="pl-c">// open IIFE</span>
    <span class="pl-c">// inside IIFE</span>
}()); <span class="pl-c">// close IIFE</span>
</pre></div>

<p>IIFE with params : </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">23</span>;
(<span class="pl-k">function</span> (<span class="pl-smi">twice</span>) {
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(twice);
}(x <span class="pl-k">*</span> <span class="pl-c1">2</span>));</pre></div>

<p>Best Practice: Avoid Creating Global Variables
Global variables have two disadvantages. First, pieces of software that rely on global variables are subject to side effects; they are less robust, behave less predictably, and are less reusable.
Second, all of the JavaScript on a web page shares the same global variables: </p>

<blockquote>
<p>your code, built-ins, analytics code, social media buttons, and so on.</p>
</blockquote>

<p>That means that name clashes can become a problem. That is why it is best to hide as many variables from the global scope as possible. For example, don’t do this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">&lt;!--</span> Don’t <span class="pl-k">do</span> <span class="pl-v">this</span> <span class="pl-c">--&gt;</span>
<span class="pl-k">&lt;</span>script<span class="pl-k">&gt;</span>
    <span class="pl-c">// Global scope</span>
    <span class="pl-k">var</span> tmp <span class="pl-k">=</span> <span class="pl-en">generateData</span>();
    <span class="pl-en">processData</span>(tmp);
    <span class="pl-en">persistData</span>(tmp);
<span class="pl-k">&lt;</span><span class="pl-k">/</span>script<span class="pl-k">&gt;</span></pre></div>

<p>The variable tmp becomes global, because its declaration is executed in global scope. But it is only used locally. Hence, we can use an IIFE (see Introducing a New Scope via an IIFE) to hide it inside a nested scope:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&lt;</span>script<span class="pl-k">&gt;</span>
    (<span class="pl-k">function</span> () {  <span class="pl-c">// open IIFE</span>
        <span class="pl-c">// Local scope</span>
        <span class="pl-k">var</span> tmp <span class="pl-k">=</span> <span class="pl-en">generateData</span>();
        <span class="pl-en">processData</span>(tmp);
        <span class="pl-en">persistData</span>(tmp);
    }());  <span class="pl-c">// close IIFE</span>
<span class="pl-k">&lt;</span><span class="pl-k">/</span>script<span class="pl-k">&gt;</span></pre></div>

<h3>
<a id="objects" class="anchor" href="#objects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objects</h3>

<p>All nonprimitive values are objects. The most common kinds of objects are:
Plain objects, which can be created by object literals (see Single Objects):</p>

<div class="highlight highlight-source-js"><pre>{
    firstName<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,
    lastName<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Doe<span class="pl-pds">'</span></span>
}</pre></div>

<p>The preceding object has two properties: the value of property firstName is 'Jane' and the value of property lastName is 'Doe'.</p>

<p>Arrays, which can be created by array literals (see Arrays):</p>

<div class="highlight highlight-source-js"><pre>[ <span class="pl-s"><span class="pl-pds">'</span>apple<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>banana<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>cherry<span class="pl-pds">'</span></span> ]</pre></div>

<p>The preceding array has three elements that can be accessed via numeric indices. For example, the index of 'apple' is 0.
Regular expressions, which can be created by regular expression literals (see Regular Expressions):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span>a<span class="pl-k">+</span>b<span class="pl-k">+</span><span class="pl-k">$</span><span class="pl-pds">/</span></span></pre></div>

<p>Single Object , each property is a (key, value) pair</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,

    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};

Dot <span class="pl-en">Operator</span> (.)<span class="pl-k">:</span> Accessing Properties via Fixed Keys

<span class="pl-s"><span class="pl-pds">`</span><span class="pl-pds">`</span><span class="pl-pds">`</span>javascript</span>
<span class="pl-s">    jane.name // 'Jane'</span>
<span class="pl-s">    jane.describe(); // 'Person named Jane';</span>
<span class="pl-s"></span></pre></div>

<p>Arbitrary Property Keys : </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { <span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">123</span> };
<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span>]
<span class="pl-c1">123</span>
<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-c1">456</span>;</pre></div>

<p>Extracting Methods : 
If you extract a method, it loses its connection with the object.</p>

<div class="highlight highlight-source-js"><pre>
<span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,

    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};

<span class="pl-k">var</span> func <span class="pl-k">=</span> <span class="pl-smi">jane</span>.<span class="pl-smi">describe</span>;
<span class="pl-en">func</span>()
TypeError<span class="pl-k">:</span> Cannot read property <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span> <span class="pl-k">of</span> <span class="pl-c1">undefined</span>

sol <span class="pl-k">:</span>

<span class="pl-k">var</span> func2 <span class="pl-k">=</span> <span class="pl-smi">jane</span>.<span class="pl-smi">describe</span>.<span class="pl-en">bind</span>(jane);
<span class="pl-en">func2</span>()
<span class="pl-s"><span class="pl-pds">'</span>Person named Jane<span class="pl-pds">'</span></span>
</pre></div>

<p>Getting properties</p>

<p>The dot operator lets you “get” a property (read its value). Here are some examples:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-c1">name</span>  <span class="pl-c">// get property `name`</span>
<span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-smi">describe</span>  <span class="pl-c">// get property `describe`</span>
[<span class="pl-c1">Function</span>]</pre></div>

<p>Getting a property that doesn’t exist returns undefined:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-smi">unknownProperty</span>
<span class="pl-c1">undefined</span>
</pre></div>

<p>Calling methods</p>

<p>The dot operator is also used to call methods:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-en">describe</span>()  <span class="pl-c">// call method `describe`</span>
<span class="pl-s"><span class="pl-pds">'</span>Person named Jane<span class="pl-pds">'</span></span></pre></div>

<p>Setting properties</p>

<p>You can use the assignment operator (=) to set the value of a property referred to via the dot notation. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>John<span class="pl-pds">'</span></span>;  <span class="pl-c">// set property `name`</span>
<span class="pl-k">&gt;</span> <span class="pl-smi">jane</span>.<span class="pl-en">describe</span>()
<span class="pl-s"><span class="pl-pds">'</span>Person named John<span class="pl-pds">'</span></span></pre></div>

<p>If a property doesn’t exist yet, setting it automatically creates it. If a property already exists, setting it changes its value.</p>

<p>Deleting properties</p>

<p>The delete operator lets you completely remove a property (the whole key-value pair) from an object. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { hello<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>world<span class="pl-pds">'</span></span> };
<span class="pl-k">&gt;</span> <span class="pl-k">delete</span> <span class="pl-smi">obj</span>.<span class="pl-smi">hello</span>
<span class="pl-c1">true</span>
<span class="pl-k">&gt;</span> <span class="pl-smi">obj</span>.<span class="pl-smi">hello</span>
<span class="pl-c1">undefined</span>
</pre></div>

<p>Bracket Operator ([]): Accessing Properties via Computed Keys :</p>

<div class="highlight highlight-source-js"><pre>
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { someProperty<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> };

<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>some<span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>Property<span class="pl-pds">'</span></span>]
<span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>

<span class="pl-k">&gt;</span> <span class="pl-k">var</span> propKey <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>someProperty<span class="pl-pds">'</span></span>;
<span class="pl-k">&gt;</span> obj[propKey]
<span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>

Getting props<span class="pl-k">:</span>
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { <span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">123</span> };
<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span>]
<span class="pl-c1">123</span>

calling methods <span class="pl-k">:</span>
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { <span class="pl-en">myMethod</span><span class="pl-k">:</span> <span class="pl-k">function</span> () { <span class="pl-k">return</span> <span class="pl-c1">true</span> } };
<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>myMethod<span class="pl-pds">'</span></span>]()
<span class="pl-c1">true</span>

setting props <span class="pl-k">:</span>
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> {};
<span class="pl-k">&gt;</span> obj[<span class="pl-s"><span class="pl-pds">'</span>anotherProperty<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span>;
<span class="pl-k">&gt;</span> <span class="pl-smi">obj</span>.<span class="pl-smi">anotherProperty</span>
<span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span>

deleting props<span class="pl-k">:</span>
<span class="pl-k">&gt;</span> <span class="pl-k">var</span> obj <span class="pl-k">=</span> { <span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-c1">1</span>, prop<span class="pl-k">:</span> <span class="pl-c1">2</span> };
<span class="pl-k">&gt;</span> <span class="pl-c1">Object</span>.<span class="pl-en">keys</span>(obj)
[ <span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>prop<span class="pl-pds">'</span></span> ]
<span class="pl-k">&gt;</span> <span class="pl-k">delete</span> obj[<span class="pl-s"><span class="pl-pds">'</span>not an identifier<span class="pl-pds">'</span></span>]
<span class="pl-c1">true</span>
<span class="pl-k">&gt;</span> <span class="pl-c1">Object</span>.<span class="pl-en">keys</span>(obj)
[ <span class="pl-s"><span class="pl-pds">'</span>prop<span class="pl-pds">'</span></span> ]

</pre></div>

<p>Objects via Constructor </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>){
    <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
}

<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
}

<span class="pl-k">var</span> jane <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>);</pre></div>

<h3>
<a id="literals-vs-wrapper-functions" class="anchor" href="#literals-vs-wrapper-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Literals vs Wrapper functions.</h3>

<ul>
<li>Primitives are immutable, compared by value ( undefined, null, boolean, string and number )</li>
<li>non-primitives are mutable ( properties can be added or deleted ), compared by identity rather than value.</li>
</ul>

<p>In JavaScript there are 5 primitive types: undefined, null, boolean, string and number. Everything else is an object. The primitive types boolean, string and number can be wrapped by their object counterparts. These objects are instances of the Boolean, String and Number constructors respectively.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">typeof</span> <span class="pl-c1">true</span>; <span class="pl-c">//"boolean"</span>
<span class="pl-k">typeof</span> <span class="pl-c1">Boolean</span>(<span class="pl-c1">true</span>); <span class="pl-c">//"boolean"</span>
<span class="pl-k">typeof</span> <span class="pl-k">new</span> <span class="pl-en">Boolean</span>(<span class="pl-c1">true</span>); <span class="pl-c">//"object"</span>
<span class="pl-k">typeof</span> (<span class="pl-k">new</span> <span class="pl-en">Boolean</span>(<span class="pl-c1">true</span>)).<span class="pl-c1">valueOf</span>(); <span class="pl-c">//"boolean"</span>

<span class="pl-k">typeof</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>; <span class="pl-c">//"string"</span>
<span class="pl-k">typeof</span> <span class="pl-c1">String</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>); <span class="pl-c">//"string"</span>
<span class="pl-k">typeof</span> <span class="pl-k">new</span> <span class="pl-en">String</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>); <span class="pl-c">//"object"</span>
<span class="pl-k">typeof</span> (<span class="pl-k">new</span> <span class="pl-en">String</span>(<span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>)).<span class="pl-c1">valueOf</span>(); <span class="pl-c">//"string"</span>

<span class="pl-k">typeof</span> <span class="pl-c1">123</span>; <span class="pl-c">//"number"</span>
<span class="pl-k">typeof</span> <span class="pl-c1">Number</span>(<span class="pl-c1">123</span>); <span class="pl-c">//"number"</span>
<span class="pl-k">typeof</span> <span class="pl-k">new</span> <span class="pl-en">Number</span>(<span class="pl-c1">123</span>); <span class="pl-c">//"object"</span>
<span class="pl-k">typeof</span> (<span class="pl-k">new</span> <span class="pl-en">Number</span>(<span class="pl-c1">123</span>)).<span class="pl-c1">valueOf</span>(); <span class="pl-c">//"number"</span>
</pre></div>

<p>If primitives have no properties, why does "abc".length return a value?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>;
<span class="pl-smi">a</span>.<span class="pl-c1">length</span>
<span class="pl-c">// actual happening</span>
(<span class="pl-k">new</span> <span class="pl-en">String</span>(<span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>)).<span class="pl-c1">length</span>
<span class="pl-c">// intermediate object gets destructed</span>


<span class="pl-k">var</span> primitive <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>september<span class="pl-pds">"</span></span>;
<span class="pl-smi">primitive</span>.<span class="pl-smi">vowels</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>;
<span class="pl-c">//new object created to set property </span>
(<span class="pl-k">new</span> <span class="pl-en">String</span>(<span class="pl-s"><span class="pl-pds">"</span>september<span class="pl-pds">"</span></span>)).<span class="pl-smi">vowels</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>;

<span class="pl-smi">primitive</span>.<span class="pl-smi">vowels</span>;
<span class="pl-c">//another new object created to retrieve property </span>
(<span class="pl-k">new</span> <span class="pl-en">String</span>(<span class="pl-s"><span class="pl-pds">"</span>september<span class="pl-pds">"</span></span>)).<span class="pl-smi">vowels</span>; <span class="pl-c">//undefined</span>


Really object is created, is there way to verify <span class="pl-k">in</span> a scientific investigation,
<span class="pl-k">&gt;</span> Yes there is, <span class="pl-k">!!!!!!!!!</span>

<span class="pl-c1">String</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">returnMe</span><span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>;
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-smi">a</span>.<span class="pl-en">returnMe</span>();  

a; <span class="pl-c">//"abc" </span>
<span class="pl-k">typeof</span> a; <span class="pl-c">//"string" (still a primitive)</span>
b; <span class="pl-c">//"abc"</span>
<span class="pl-k">typeof</span> b; <span class="pl-c">//"object"</span>



a; <span class="pl-c">//"abc" </span>
<span class="pl-k">typeof</span> a; <span class="pl-c">//"string" (still a primitive)</span>
b; <span class="pl-c">//"abc"</span>
<span class="pl-k">typeof</span> b; <span class="pl-c">//"object"</span>
</pre></div>

<h3>
<a id="inheritance" class="anchor" href="#inheritance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inheritance</h3>

<p>The Prototype Relationship Between Objects</p>

<p>The prototype relationship between two objects is about inheritance: every object can have another object as its prototype</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span> __proto__ <span class="pl-k">==</span> [[Prototype]] some javscript engines support __proto__ special key <span class="pl-k">for</span> getting and setting prototype.</pre></div>

<p><img src="http://speakingjs.com/es5/images/spjs_2101.png" alt="prototype chain"></p>

<p>ex :</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> proto <span class="pl-k">=</span> {
    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>name: <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};
<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    __proto__<span class="pl-k">:</span> proto,
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>obj<span class="pl-pds">'</span></span>
};

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>obj2<span class="pl-pds">'</span></span>
};

<span class="pl-smi">obj</span>.<span class="pl-smi">__proto__</span> <span class="pl-k">===</span> proto 
<span class="pl-smi">obj2</span>.<span class="pl-smi">__proto__</span> <span class="pl-c">// root Object</span>
<span class="pl-smi">proto</span>.<span class="pl-smi">__proto__</span> <span class="pl-c">// root Object</span>
</pre></div>

<p>Overriding</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">obj</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () { <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>overridden<span class="pl-pds">'</span></span> };
<span class="pl-smi">obj</span>.<span class="pl-en">describe</span>()
</pre></div>

<p>Prototypes are great for sharing data between objects: several objects get the same prototype, which holds all shared properties.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,
    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};
<span class="pl-k">var</span> tarzan <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tarzan<span class="pl-pds">'</span></span>,
    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};</pre></div>

<p><img src="http://speakingjs.com/es5/images/spjs_2102.png" alt="prototype chain"></p>

<div class="highlight highlight-source-js"><pre>
<span class="pl-k">var</span> PersonProto <span class="pl-k">=</span> {
    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};
<span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    __proto__<span class="pl-k">:</span> PersonProto,
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>
};
<span class="pl-k">var</span> tarzan <span class="pl-k">=</span> {
    __proto__<span class="pl-k">:</span> PersonProto,
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tarzan<span class="pl-pds">'</span></span>
};


<span class="pl-smi">jane</span>.<span class="pl-en">describe</span>()
<span class="pl-smi">tarzan</span>.<span class="pl-en">describe</span>()</pre></div>

<p>Object.create </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">&gt;</span>syntax
<span class="pl-c1">Object</span>.<span class="pl-en">create</span>(proto, propDescObj<span class="pl-k">?</span>)

<span class="pl-k">var</span> PersonProto <span class="pl-k">=</span> {
    <span class="pl-en">describe</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>Person named <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>;
    }
};
<span class="pl-k">var</span> jane <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-en">create</span>(PersonProto, {
    name<span class="pl-k">:</span> { value<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>, writable<span class="pl-k">:</span> <span class="pl-c1">true</span> }
});

or manually you can create them.

<span class="pl-k">var</span> jane <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-en">create</span>(PersonProto);
<span class="pl-smi">jane</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>;</pre></div>

<p>Checking Whether a Property Exists</p>

<p><code>in</code> operator</p>

<p><code>propKey in obj</code></p>

<p>or </p>

<p><code>&lt;target-Object&gt;.hasOwnProperty(propKey)</code></p>

<p>or </p>

<p><code>Object.hasOwnProperty(propKey)</code></p>

<p>Function prototyping.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
}
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Person <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">function</span> <span class="pl-en">Worker</span>(<span class="pl-smi">name</span>, <span class="pl-smi">title</span>) {
    <span class="pl-smi">Person</span>.<span class="pl-c1">call</span>(<span class="pl-v">this</span>, name);
    <span class="pl-v">this</span>.<span class="pl-c1">title</span> <span class="pl-k">=</span> title;
}

<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span>.<span class="pl-smi">__proto__</span> <span class="pl-k">=</span> <span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>;
<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">title</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">var</span> user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Worker</span>(<span class="pl-s"><span class="pl-pds">'</span>Kamesh<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>Devloper<span class="pl-pds">'</span></span>)
user <span class="pl-k">instanceof</span> Worker
user <span class="pl-k">instanceof</span> Person</pre></div>

<p>ES5 to help. ( Object.create setting proper prototype internal without manually
altering the prototype chain )</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
}
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Person <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">function</span> <span class="pl-en">Worker</span>(<span class="pl-smi">name</span>, <span class="pl-smi">title</span>) {
    <span class="pl-smi">Person</span>.<span class="pl-c1">call</span>(<span class="pl-v">this</span>, name);
    <span class="pl-v">this</span>.<span class="pl-c1">title</span> <span class="pl-k">=</span> title;
}

<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-en">create</span>(<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>);
<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">title</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">var</span> user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Worker</span>(<span class="pl-s"><span class="pl-pds">'</span>Kamesh<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>Devloper<span class="pl-pds">'</span></span>)
user <span class="pl-k">instanceof</span> Worker
user <span class="pl-k">instanceof</span> Person</pre></div>

<p>How to call super function ? is there super available in javascript
No but we can mimic it.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">user</span>.<span class="pl-en">describe</span>(); <span class="pl-c">// Developer Kamesh.</span>

<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-smi">__proto__</span> <span class="pl-c">// worker prototype</span>
                .<span class="pl-smi">__proto__</span> <span class="pl-c">// person prototype</span>
                .<span class="pl-smi">describe</span>.<span class="pl-c1">apply</span>(<span class="pl-v">this</span>,<span class="pl-v">arguments</span>); <span class="pl-c">// person describe fn.</span>
};

or 

<span class="pl-smi">Worker</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">describe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-smi">Person</span>.<span class="pl-smi">describe</span>.<span class="pl-c1">apply</span>(<span class="pl-v">this</span>,<span class="pl-v">arguments</span>); <span class="pl-c">// person describe fn.</span>
};
</pre></div>

<p>What does “this” actually mean and how is it decided?</p>

<p>For example, if I have a class Boat(), which has a method moveBoat(), when refering to “this” inside of the moveBoat() method, we are actually accessing the newly created object of Boat().</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">class</span> <span class="pl-en">Boat</span>{
    <span class="pl-k">boolean</span> <span class="pl-en">isReady</span>(){
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">moveBoat</span>(){
        <span class="pl-k">return</span> <span class="pl-v">this</span><span class="pl-k">.</span>isReady(); <span class="pl-c">// this refers to newly created object.</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-smi">Boat</span> miniTitanic <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Boat</span>();
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(miniTitanic<span class="pl-k">.</span>moveBoat());
    }
}</pre></div>

<p>however it is not the only rule and “this” can often refer to a different <code>object</code> from a different <code>execution context</code></p>

<blockquote>
<p>function caller determines <code>this</code> context.</p>
</blockquote>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">describe</span>(){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>context <span class="pl-pds">'</span></span>,<span class="pl-v">this</span>);
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>User was identified as <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>);
}

<span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jane<span class="pl-pds">'</span></span>,
    <span class="pl-s"><span class="pl-pds">'</span>describe<span class="pl-pds">'</span></span><span class="pl-k">:</span> describe <span class="pl-c">// method</span>
};
<span class="pl-k">var</span> tarzan <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tarzan<span class="pl-pds">'</span></span>,
    describe<span class="pl-k">:</span> describe <span class="pl-c">// method;</span>
};

<span class="pl-smi">jane</span>.<span class="pl-en">describe</span>();
<span class="pl-smi">tarzan</span>.<span class="pl-en">describe</span>();</pre></div>

<p>or </p>

<blockquote>
<p>Remember call,apply and bind. which can invoke the function
with provided context <code>this</code> and arguments.</p>
</blockquote>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">describe</span>(){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>context <span class="pl-pds">'</span></span>,<span class="pl-v">this</span>);
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>User was identified as <span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-v">this</span>.<span class="pl-c1">name</span>);
}

<span class="pl-k">var</span> smith <span class="pl-k">=</span> {
    name <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>smith<span class="pl-pds">'</span></span>
}

<span class="pl-k">var</span> jane <span class="pl-k">=</span> {
    name <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>jane<span class="pl-pds">'</span></span>
}

<span class="pl-smi">describe</span>.<span class="pl-c1">call</span>(smith)
<span class="pl-smi">describe</span>.<span class="pl-c1">apply</span>(jane)
</pre></div>

<h3>
<a id="synchronous-vs-asynchronous" class="anchor" href="#synchronous-vs-asynchronous" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Synchronous Vs Asynchronous</h3>

<h2>
<a id="--blocking-vs-non-blocking" class="anchor" href="#--blocking-vs-non-blocking" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>- Blocking vs non-blocking</h2>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/kamesh-a/Javascript">Javascript</a> is maintained by <a href="https://github.com/kamesh-a">kamesh-a</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
